"""Tests for sseed.file_operations module.

Tests file I/O operations for mnemonics and SLIP-39 shards.
"""

import os
import tempfile
from pathlib import Path
from unittest.mock import patch

import pytest

from sseed.bip39 import generate_mnemonic
from sseed.exceptions import FileError
from sseed.file_operations import (
    read_from_stdin,
    read_mnemonic_from_file,
    read_shards_from_files,
    write_mnemonic_to_file,
    write_shards_to_file,
    write_shards_to_separate_files,
    write_to_stdout,
)


class TestFileOperations:
    """Test file I/O operations."""

    def setup_method(self):
        """Set up temporary directory for each test."""
        import tempfile

        self.temp_dir = Path(tempfile.mkdtemp())

    def teardown_method(self):
        """Clean up temporary directory after each test."""
        import shutil

        if self.temp_dir.exists():
            shutil.rmtree(self.temp_dir)

    def test_write_and_read_mnemonic(self) -> None:
        """Test writing and reading a mnemonic to/from file."""
        mnemonic = generate_mnemonic()

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".txt"
        ) as tmp_file:
            tmp_path = tmp_file.name

        try:
            # Write mnemonic to file (without comments for this basic test)
            write_mnemonic_to_file(mnemonic, tmp_path, include_comments=False)

            # Read it back
            read_mnemonic = read_mnemonic_from_file(tmp_path)

            assert read_mnemonic == mnemonic

        finally:
            # Clean up
            if os.path.exists(tmp_path):
                os.unlink(tmp_path)

    def test_read_mnemonic_with_comments(self) -> None:
        """Test reading mnemonic from file with comments."""
        mnemonic = generate_mnemonic()

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".txt"
        ) as tmp_file:
            # Write file with comments
            tmp_file.write("# This is a comment\n")
            tmp_file.write("\n")  # Empty line
            tmp_file.write("# Another comment\n")
            tmp_file.write(f"{mnemonic}\n")
            tmp_file.write("# Trailing comment\n")
            tmp_path = tmp_file.name

        try:
            # Should read the mnemonic, skipping comments
            read_mnemonic = read_mnemonic_from_file(tmp_path)
            assert read_mnemonic == mnemonic

        finally:
            os.unlink(tmp_path)

    def test_read_mnemonic_nonexistent_file(self) -> None:
        """Test reading from non-existent file."""
        with pytest.raises(FileError) as exc_info:
            read_mnemonic_from_file("nonexistent_file.txt")

        assert "not found" in str(exc_info.value)

    def test_read_mnemonic_empty_file(self) -> None:
        """Test reading from empty file."""
        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".txt"
        ) as tmp_file:
            # Write only comments and empty lines
            tmp_file.write("# Only comments\n")
            tmp_file.write("# No actual content\n")
            tmp_path = tmp_file.name

        try:
            with pytest.raises(FileError) as exc_info:
                read_mnemonic_from_file(tmp_path)

            assert "No mnemonic found" in str(exc_info.value)

        finally:
            os.unlink(tmp_path)

    def test_write_shards_to_file(self) -> None:
        """Test writing multiple shards to a single file."""
        # Create test shards (dummy data for this test)
        shards = [
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon",
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon",
        ]

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".txt"
        ) as tmp_file:
            tmp_path = tmp_file.name

        try:
            # Write shards to file
            write_shards_to_file(shards, tmp_path)

            # Read the file and verify content
            with open(tmp_path, "r", encoding="utf-8") as f:
                content = f.read()

            assert "# SLIP-39 Shards File" in content
            assert "# Generated by sseed on" in content
            assert shards[0] in content
            assert shards[1] in content

        finally:
            if os.path.exists(tmp_path):
                os.unlink(tmp_path)

    def test_write_shards_to_separate_files(self):
        """Test writing shards to separate files."""
        shards = [
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon",
            "test test test test test test test test test test test test test test test test test test test test",
        ]

        base_path = self.temp_dir / "test_shards.txt"

        # Write shards to separate files
        file_paths = write_shards_to_separate_files(shards, str(base_path))

        # Verify correct number of files created
        assert len(file_paths) == 2

        # Verify file naming convention
        expected_paths = [
            str(self.temp_dir / "test_shards_01.txt"),
            str(self.temp_dir / "test_shards_02.txt"),
        ]
        assert file_paths == expected_paths

        # Verify files exist and contain correct content
        for i, file_path in enumerate(file_paths):
            assert Path(file_path).exists()

            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()

            # Check for enhanced comments (Phase 6)
            assert "# SLIP-39 Shard File" in content
            assert f"# Shard {i+1} of 2" in content
            assert "# Generated by sseed on" in content
            assert "# File format: Plain text UTF-8" in content

            # Check shard content
            lines = [
                line.strip()
                for line in content.split("\n")
                if line.strip() and not line.startswith("#")
            ]
            assert len(lines) == 1
            assert lines[0] == shards[i]

    def test_write_shards_to_separate_files_custom_extension(self):
        """Test writing shards to separate files with custom extension."""
        shards = ["shard1", "shard2"]
        base_path = self.temp_dir / "custom.dat"

        file_paths = write_shards_to_separate_files(shards, str(base_path))

        expected_paths = [
            str(self.temp_dir / "custom_01.dat"),
            str(self.temp_dir / "custom_02.dat"),
        ]
        assert file_paths == expected_paths

        # Verify files exist
        for file_path in file_paths:
            assert Path(file_path).exists()

    def test_write_shards_to_separate_files_no_extension(self):
        """Test writing shards to separate files without extension."""
        shards = ["shard1", "shard2"]
        base_path = self.temp_dir / "noext"

        file_paths = write_shards_to_separate_files(shards, str(base_path))

        expected_paths = [
            str(self.temp_dir / "noext_01.txt"),
            str(self.temp_dir / "noext_02.txt"),
        ]
        assert file_paths == expected_paths

    def test_enhanced_file_format_comments(self):
        """Test Phase 6 enhanced comment format in files."""
        # Test mnemonic file with comments
        mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        file_path = self.temp_dir / "test_mnemonic_comments.txt"

        write_mnemonic_to_file(mnemonic, str(file_path), include_comments=True)

        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Check for enhanced comments (Phase 6)
        assert "# BIP-39 Mnemonic File" in content
        assert "# Generated by sseed on" in content
        assert "# File format: Plain text UTF-8" in content
        assert "# Keep this file extremely secure" in content

        # Test mnemonic file without comments
        file_path_no_comments = self.temp_dir / "test_mnemonic_no_comments.txt"
        write_mnemonic_to_file(
            mnemonic, str(file_path_no_comments), include_comments=False
        )

        with open(file_path_no_comments, "r", encoding="utf-8") as f:
            content_no_comments = f.read()

        # Should only contain the mnemonic
        assert content_no_comments.strip() == mnemonic
        assert "# BIP-39 Mnemonic File" not in content_no_comments

    def test_enhanced_shards_file_format(self):
        """Test Phase 6 enhanced comment format for shards file."""
        # Use valid BIP-39 mnemonics as test shard data
        shards = [
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon",
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon affair",
        ]
        file_path = self.temp_dir / "test_shards_enhanced.txt"

        write_shards_to_file(shards, str(file_path))

        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Check for enhanced comments (Phase 6)
        assert "# SLIP-39 Shards File" in content
        assert "# Generated by sseed on" in content
        assert "# Contains 3 SLIP-39 shards" in content
        assert "# File format: Plain text UTF-8" in content
        assert "# Each shard is on its own line" in content

        # Check individual shard comments
        assert "# Shard 1 of 3" in content
        assert "# Shard 2 of 3" in content
        assert "# Shard 3 of 3" in content

    def test_cross_platform_compatibility(self):
        """Test Phase 6 cross-platform file compatibility."""
        # Test various filename edge cases
        test_cases = [
            "normal_file.txt",
            "file with spaces.txt",
            "file-with-dashes.txt",
            "file_with_underscores.txt",
            "file.with.dots.txt",
        ]

        for filename in test_cases:
            mnemonic = "test test test test test test test test test test test test"
            file_path = self.temp_dir / filename

            # Should not raise an exception
            write_mnemonic_to_file(mnemonic, str(file_path))

            # File should exist and be readable
            assert file_path.exists()

            content = read_mnemonic_from_file(str(file_path))
            assert content == mnemonic

    def test_utf8_encoding_handling(self):
        """Test Phase 6 UTF-8 encoding requirements."""
        # Test with valid 12-word BIP-39 mnemonic using basic ASCII characters
        mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        file_path = self.temp_dir / "unicode_test.txt"

        write_mnemonic_to_file(mnemonic, str(file_path), include_comments=False)

        # Read back and verify content is preserved
        content = read_mnemonic_from_file(str(file_path))
        assert content == mnemonic

        # Verify file is actually UTF-8 encoded by checking it can be read as UTF-8
        with open(file_path, "rb") as f:
            raw_bytes = f.read()

        # Should be able to decode as UTF-8 without errors
        decoded = raw_bytes.decode("utf-8")
        assert mnemonic in decoded

        # Verify file starts with UTF-8 BOM or is plain ASCII (both valid UTF-8)
        assert raw_bytes.startswith(b"\xef\xbb\xbf") or all(
            b < 128 for b in raw_bytes if b != ord("\n")
        )

    def test_read_shards_from_files(self) -> None:
        """Test reading shards from multiple files."""
        # Use valid 12-word BIP-39 mnemonics as test data (instead of real SLIP-39 shards)
        shards = [
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon",
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon affair",
        ]

        with tempfile.TemporaryDirectory() as tmp_dir:
            # Create separate files for each shard
            file_paths = []
            for i, shard in enumerate(shards):
                file_path = os.path.join(tmp_dir, f"shard_{i+1}.txt")
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(f"# Shard {i+1}\n")
                    f.write(f"{shard}\n")
                file_paths.append(file_path)

            # Read shards back
            read_shards = read_shards_from_files(file_paths)

            assert read_shards == shards

    def test_read_shards_from_files_missing_file(self) -> None:
        """Test reading shards when one file is missing."""
        with tempfile.TemporaryDirectory() as tmp_dir:
            # Create one valid file with valid BIP-39 mnemonic
            valid_file = os.path.join(tmp_dir, "shard1.txt")
            with open(valid_file, "w", encoding="utf-8") as f:
                f.write(
                    "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\n"
                )

            # Reference a non-existent file
            missing_file = os.path.join(tmp_dir, "missing.txt")

            with pytest.raises(FileError) as exc_info:
                read_shards_from_files([valid_file, missing_file])

            assert "missing.txt" in str(exc_info.value)

    @patch("sys.stdin")
    def test_read_from_stdin(self, mock_stdin) -> None:
        """Test reading from stdin."""
        # Mock stdin input
        mock_stdin.__iter__.return_value = iter(
            ["# Comment line\n", "test mnemonic words\n", "# Another comment\n"]
        )

        result = read_from_stdin()
        assert result == "test mnemonic words"

    @patch("sys.stdin")
    def test_read_from_stdin_empty(self, mock_stdin) -> None:
        """Test reading from empty stdin."""
        mock_stdin.__iter__.return_value = iter(["# Only comments\n", "# No content\n"])

        with pytest.raises(FileError) as exc_info:
            read_from_stdin()

        assert "No valid input received" in str(exc_info.value)

    @patch("builtins.print")
    def test_write_to_stdout(self, mock_print) -> None:
        """Test writing to stdout."""
        test_content = "test output content"

        write_to_stdout(test_content)

        mock_print.assert_called_once_with(test_content)

    def test_file_path_sanitization(self) -> None:
        """Test that filename sanitization works."""
        dangerous_filename = "test..file"  # Simpler test for now
        safe_content = "safe mnemonic content"

        with tempfile.TemporaryDirectory() as tmp_dir:
            # This should sanitize the filename
            file_path = os.path.join(tmp_dir, dangerous_filename)

            # Write should sanitize the filename (without comments for this test)
        write_mnemonic_to_file(safe_content, file_path, include_comments=False)

        # Should have created a file in tmp_dir
        created_files = list(Path(tmp_dir).rglob("*"))
        assert len(created_files) > 0

        # Read it back to verify it worked
        written_file = created_files[0]
        with open(written_file, "r", encoding="utf-8") as f:
            content = f.read().strip()
        assert content == safe_content

    def test_unicode_handling(self) -> None:
        """Test proper Unicode handling in files."""
        # Use a valid 12-word BIP-39 mnemonic for Unicode testing
        mnemonic_with_unicode = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".txt"
        ) as tmp_file:
            tmp_path = tmp_file.name

        try:
            # Write and read back
            write_mnemonic_to_file(mnemonic_with_unicode, tmp_path)
            read_mnemonic = read_mnemonic_from_file(tmp_path)

            # Should handle Unicode properly (after normalization)
            assert read_mnemonic is not None
            assert len(read_mnemonic) > 0

        finally:
            if os.path.exists(tmp_path):
                os.unlink(tmp_path)
