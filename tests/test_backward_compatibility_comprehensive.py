"""Comprehensive backward compatibility tests for Stage 3.

This module ensures that all existing functionality continues to work
after implementing multi-language support, maintaining 100% backward compatibility.
"""

import tempfile
from pathlib import Path

import pytest

from sseed.cli.commands.gen import GenCommand
from sseed.cli.commands.restore import RestoreCommand
from sseed.cli.commands.seed import SeedCommand
from sseed.cli.commands.shard import ShardCommand


class TestBackwardCompatibilityComprehensive:
    """Test comprehensive backward compatibility across all CLI operations."""

    @pytest.fixture
    def temp_dir(self):
        """Create a temporary directory for test files."""
        with tempfile.TemporaryDirectory() as temp_dir:
            yield Path(temp_dir)

    def test_default_english_generation_unchanged(self, temp_dir):
        """Test that default mnemonic generation still produces English mnemonics."""
        mnemonic_file = temp_dir / "default_mnemonic.txt"

        class GenArgs:
            language = "en"  # Default behavior
            output = str(mnemonic_file)
            show_entropy = False
            words = 24  # Default behavior

        gen_cmd = GenCommand()
        result = gen_cmd.handle(GenArgs())

        assert result == 0
        assert mnemonic_file.exists()

        # Should still be English by default
        content = mnemonic_file.read_text(encoding="utf-8")
        assert "Language: English (en)" in content

        # Extract and validate mnemonic
        mnemonic = self._extract_mnemonic(content)
        assert len(mnemonic.split()) == 24

        # Should be valid English mnemonic
        from bip_utils import Bip39Languages

        from sseed.bip39 import validate_mnemonic

        assert validate_mnemonic(mnemonic, Bip39Languages.ENGLISH)

    def test_existing_english_file_workflows(self, temp_dir):
        """Test that existing English mnemonic files work with all commands."""
        # Create a traditional English mnemonic file (without language metadata)
        mnemonic_file = temp_dir / "traditional_english.txt"

        # Write a traditional format file (no language info)
        traditional_content = """# BIP-39 Mnemonic File
# Generated by sseed
#
# This file contains a BIP-39 mnemonic for cryptocurrency wallet recovery.
# Keep this file extremely secure and consider splitting into SLIP-39 shards.
# Anyone with access to this mnemonic can access your funds.
#
# File format: Plain text UTF-8
# Lines starting with '#' are comments and will be ignored.
#
abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"""

        mnemonic_file.write_text(traditional_content, encoding="utf-8")

        # Test 1: Shard operation should work
        shard_prefix = temp_dir / "traditional_shards"

        class ShardArgs:
            input = str(mnemonic_file)
            output = str(shard_prefix)
            group = "2-of-3"
            separate = True

        shard_cmd = ShardCommand()
        assert shard_cmd.handle(ShardArgs()) == 0

        # Should create shard files
        shard_files = list(temp_dir.glob("traditional_shards_*.txt"))
        assert len(shard_files) == 3

        # Test 2: Seed generation should work
        seed_file = temp_dir / "traditional_seed.txt"

        class SeedArgs:
            input = str(mnemonic_file)
            output = str(seed_file)
            passphrase = False
            format = "hex"

        seed_cmd = SeedCommand()
        assert seed_cmd.handle(SeedArgs()) == 0
        assert seed_file.exists()

        # Test 3: Restore should work
        restored_file = temp_dir / "traditional_restored.txt"

        class RestoreArgs:
            shards = [str(f) for f in shard_files[:2]]
            output = str(restored_file)
            show_entropy = False

        restore_cmd = RestoreCommand()
        assert restore_cmd.handle(RestoreArgs()) == 0
        assert restored_file.exists()

    def test_stdout_output_format_unchanged(self, temp_dir):
        """Test that stdout output format remains unchanged for existing scripts."""

        # Test gen command stdout
        class GenArgs:
            language = "en"
            output = None  # stdout
            show_entropy = False
            words = 24  # Default behavior

        gen_cmd = GenCommand()
        result = gen_cmd.handle(GenArgs())
        assert result == 0

        # Test shard command stdout
        mnemonic_file = temp_dir / "test_mnemonic.txt"

        class GenArgsFile:
            language = "en"
            output = str(mnemonic_file)
            show_entropy = False
            words = 24  # Default behavior

        gen_cmd.handle(GenArgsFile())

        class ShardArgs:
            input = str(mnemonic_file)
            output = None  # stdout
            group = "2-of-3"
            separate = False

        shard_cmd = ShardCommand()
        result = shard_cmd.handle(ShardArgs())
        assert result == 0

        # Test seed command stdout
        class SeedArgs:
            input = str(mnemonic_file)
            output = None  # stdout
            passphrase = False
            format = "hex"

        seed_cmd = SeedCommand()
        result = seed_cmd.handle(SeedArgs())
        assert result == 0

    def test_file_format_backward_compatibility(self, temp_dir):
        """Test that existing file formats are still supported."""
        # Test various legacy file formats
        legacy_formats = [
            # Format 1: Minimal comments
            """# BIP-39 Mnemonic
abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about""",
            # Format 2: No comments at all
            """abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about""",
            # Format 3: Extra whitespace
            """
            # BIP-39 Mnemonic File
            
            abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about
            
            """,
        ]

        for i, content in enumerate(legacy_formats):
            legacy_file = temp_dir / f"legacy_{i}.txt"
            legacy_file.write_text(content, encoding="utf-8")

            # Test that all commands can read these formats
            # 1. Shard operation
            class ShardArgs:
                input = str(legacy_file)
                output = None  # stdout
                group = "2-of-3"
                separate = False

            shard_cmd = ShardCommand()
            assert shard_cmd.handle(ShardArgs()) == 0

            # 2. Seed generation
            class SeedArgs:
                input = str(legacy_file)
                output = None  # stdout
                passphrase = False
                format = "hex"

            seed_cmd = SeedCommand()
            assert seed_cmd.handle(SeedArgs()) == 0

    def test_error_handling_unchanged(self):
        """Test that error handling behavior is unchanged."""

        # Test invalid language (should return error code, not exception)
        class GenArgs:
            language = "invalid"
            output = None
            show_entropy = False
            words = 24  # Default behavior

        gen_cmd = GenCommand()
        result = gen_cmd.handle(GenArgs())
        assert result != 0  # Should return error code

    def _extract_mnemonic(self, file_content: str) -> str:
        """Extract mnemonic from file content (ignoring comments)."""
        lines = file_content.strip().split("\n")
        mnemonic_lines = [line for line in lines if not line.startswith("#")]
        return " ".join(mnemonic_lines).strip()
