"""Comprehensive tests for file_operations/validators.py module.

This module tests all validator functions to boost coverage significantly.
"""

import os
import tempfile
import unittest
from pathlib import Path
from unittest.mock import (
    mock_open,
    patch,
)

from sseed.exceptions import FileError
from sseed.file_operations.validators import (
    check_file_permissions,
    count_non_comment_lines,
    detect_file_format,
    extract_metadata_from_comments,
    validate_file_structure,
    validate_utf8_encoding,
)


class TestFileFormatDetection(unittest.TestCase):
    """Test file format detection functionality."""

    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up test fixtures."""
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_detect_bip39_format_with_header(self):
        """Test detection of BIP-39 format with header comment."""
        content = """# BIP-39 Mnemonic File
# Generated by sseed on 2024-01-15 10:30:00
abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"""

        test_file = Path(self.temp_dir) / "test_bip39.txt"
        test_file.write_text(content, encoding="utf-8")

        result = detect_file_format(str(test_file))
        self.assertEqual(result, "bip39")

    def test_detect_slip39_single_shard_format(self):
        """Test detection of SLIP-39 single shard format."""
        content = """# SLIP-39 Shard File
# Generated by sseed on 2024-01-15 10:30:00
# Shard 1 of 3
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic"""

        test_file = Path(self.temp_dir) / "test_slip39_single.txt"
        test_file.write_text(content, encoding="utf-8")

        result = detect_file_format(str(test_file))
        self.assertEqual(result, "slip39")

    def test_detect_slip39_multi_shard_format(self):
        """Test detection of SLIP-39 multi-shard format."""
        content = """# SLIP-39 Shards File
# Generated by sseed on 2024-01-15 10:30:00
# Contains 3 SLIP-39 shards
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic"""

        test_file = Path(self.temp_dir) / "test_slip39_multi.txt"
        test_file.write_text(content, encoding="utf-8")

        result = detect_file_format(str(test_file))
        self.assertEqual(result, "slip39")

    def test_detect_bip39_format_by_content_single_line(self):
        """Test detection of BIP-39 format by single line content."""
        content = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"

        test_file = Path(self.temp_dir) / "test_bip39_simple.txt"
        test_file.write_text(content, encoding="utf-8")

        result = detect_file_format(str(test_file))
        self.assertEqual(result, "bip39")

    def test_detect_slip39_format_by_content_multiple_lines(self):
        """Test detection of SLIP-39 format by multiple line content."""
        content = """academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic"""

        test_file = Path(self.temp_dir) / "test_slip39_simple.txt"
        test_file.write_text(content, encoding="utf-8")

        result = detect_file_format(str(test_file))
        self.assertEqual(result, "slip39")

    def test_detect_unknown_format(self):
        """Test detection returns unknown for unrecognizable format."""
        content = """# Some other format
# Not a recognized format
"""

        test_file = Path(self.temp_dir) / "test_unknown.txt"
        test_file.write_text(content, encoding="utf-8")

        result = detect_file_format(str(test_file))
        self.assertEqual(result, "unknown")

    def test_detect_file_not_found(self):
        """Test detection raises FileError for non-existent file."""
        with self.assertRaises(FileError) as context:
            detect_file_format("/path/that/does/not/exist.txt")

        self.assertIn("File not found", str(context.exception))

    @patch("builtins.open", side_effect=Exception("Read error"))
    def test_detect_file_read_error(self, mock_file):
        """Test detection handles file read errors."""
        test_file = Path(self.temp_dir) / "test_error.txt"
        test_file.write_text("content", encoding="utf-8")

        with self.assertRaises(FileError) as context:
            detect_file_format(str(test_file))

        self.assertIn("Failed to detect file format", str(context.exception))


class TestFileStructureValidation(unittest.TestCase):
    """Test file structure validation functionality."""

    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up test fixtures."""
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_validate_valid_file_structure(self):
        """Test validation of valid file structure."""
        content = """# Valid file
some content line"""

        test_file = Path(self.temp_dir) / "valid.txt"
        test_file.write_text(content, encoding="utf-8")

        is_valid, error_msg = validate_file_structure(str(test_file))
        self.assertTrue(is_valid)
        self.assertIsNone(error_msg)

    def test_validate_file_not_found(self):
        """Test validation of non-existent file."""
        is_valid, error_msg = validate_file_structure("/path/that/does/not/exist.txt")
        self.assertFalse(is_valid)
        self.assertIn("File not found", error_msg)

    def test_validate_path_not_file(self):
        """Test validation when path is not a file."""
        is_valid, error_msg = validate_file_structure(self.temp_dir)
        self.assertFalse(is_valid)
        self.assertIn("Path is not a file", error_msg)

    def test_validate_empty_file(self):
        """Test validation of empty file."""
        test_file = Path(self.temp_dir) / "empty.txt"
        test_file.write_text("", encoding="utf-8")

        is_valid, error_msg = validate_file_structure(str(test_file))
        self.assertFalse(is_valid)
        self.assertIn("File is empty", error_msg)

    def test_validate_only_comments_file(self):
        """Test validation of file with only comments."""
        content = """# Comment 1
# Comment 2
# Comment 3"""

        test_file = Path(self.temp_dir) / "comments_only.txt"
        test_file.write_text(content, encoding="utf-8")

        is_valid, error_msg = validate_file_structure(str(test_file))
        self.assertFalse(is_valid)
        self.assertIn("File contains no content lines", error_msg)

    def test_validate_unicode_decode_error(self):
        """Test validation handles unicode decode errors."""
        test_file = Path(self.temp_dir) / "invalid_utf8.txt"
        with open(test_file, "wb") as f:
            f.write(b"\x80\x81\x82")  # Invalid UTF-8 sequence

        is_valid, error_msg = validate_file_structure(str(test_file))
        self.assertFalse(is_valid)
        self.assertIn("File is not valid UTF-8", error_msg)

    @patch("builtins.open", side_effect=Exception("Read error"))
    def test_validate_file_read_error(self, mock_file):
        """Test validation handles file read errors."""
        test_file = Path(self.temp_dir) / "test_error.txt"
        test_file.write_text("content", encoding="utf-8")

        is_valid, error_msg = validate_file_structure(str(test_file))
        self.assertFalse(is_valid)
        self.assertIn("Error validating file structure", error_msg)


class TestCommentLineCounter(unittest.TestCase):
    """Test comment line counting functionality."""

    def test_count_no_comments(self):
        """Test counting lines with no comments."""
        content = """line1
line2
line3"""
        result = count_non_comment_lines(content)
        self.assertEqual(result, 3)

    def test_count_with_comments(self):
        """Test counting lines with comments."""
        content = """# Comment 1
line1
# Comment 2
line2
line3"""
        result = count_non_comment_lines(content)
        self.assertEqual(result, 3)

    def test_count_only_comments(self):
        """Test counting with only comments."""
        content = """# Comment 1
# Comment 2
# Comment 3"""
        result = count_non_comment_lines(content)
        self.assertEqual(result, 0)

    def test_count_empty_lines(self):
        """Test counting with empty lines."""
        content = """line1

line2

# Comment"""
        result = count_non_comment_lines(content)
        self.assertEqual(result, 2)

    def test_count_empty_string(self):
        """Test counting empty string."""
        result = count_non_comment_lines("")
        self.assertEqual(result, 0)

    def test_count_whitespace_lines(self):
        """Test counting with whitespace-only lines."""
        content = """line1
   
\t
line2"""
        result = count_non_comment_lines(content)
        self.assertEqual(result, 2)


class TestMetadataExtraction(unittest.TestCase):
    """Test metadata extraction functionality."""

    def test_extract_bip39_metadata(self):
        """Test extracting BIP-39 metadata."""
        content = """# BIP-39 Mnemonic File
# Generated by sseed on 2024-01-15 10:30:00
abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"""

        metadata = extract_metadata_from_comments(content)
        self.assertEqual(metadata["file_type"], "bip39")
        self.assertEqual(metadata["generated_at"], "2024-01-15 10:30:00")

    def test_extract_slip39_single_metadata(self):
        """Test extracting SLIP-39 single shard metadata."""
        content = """# SLIP-39 Shard File
# Generated by sseed on 2024-01-15 10:30:00
# Shard 2 of 5
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic"""

        metadata = extract_metadata_from_comments(content)
        self.assertEqual(metadata["file_type"], "slip39_single")
        self.assertEqual(metadata["generated_at"], "2024-01-15 10:30:00")
        self.assertEqual(metadata["shard_number"], 2)
        self.assertEqual(metadata["total_shards"], 5)

    def test_extract_slip39_multi_metadata(self):
        """Test extracting SLIP-39 multi-shard metadata."""
        content = """# SLIP-39 Shards File
# Generated by sseed on 2024-01-15 10:30:00
# Contains 3 SLIP-39 shards
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic
academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic academic"""

        metadata = extract_metadata_from_comments(content)
        self.assertEqual(metadata["file_type"], "slip39_multi")
        self.assertEqual(metadata["generated_at"], "2024-01-15 10:30:00")
        self.assertEqual(metadata["shard_count"], 3)

    def test_extract_no_metadata(self):
        """Test extracting metadata from content with no metadata."""
        content = """# Some random comment
# Another comment
some content line"""

        metadata = extract_metadata_from_comments(content)
        self.assertEqual(metadata, {})

    def test_extract_partial_metadata(self):
        """Test extracting partial metadata."""
        content = """# BIP-39 Mnemonic File
# Some other comment
abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"""

        metadata = extract_metadata_from_comments(content)
        self.assertEqual(metadata["file_type"], "bip39")
        self.assertNotIn("generated_at", metadata)

    def test_extract_complex_timestamp(self):
        """Test extracting complex timestamp format."""
        content = """# Generated by sseed on 2024-12-31 23:59:59"""

        metadata = extract_metadata_from_comments(content)
        self.assertEqual(metadata["generated_at"], "2024-12-31 23:59:59")


class TestUTF8Validation(unittest.TestCase):
    """Test UTF-8 encoding validation functionality."""

    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up test fixtures."""
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_validate_valid_utf8(self):
        """Test validation of valid UTF-8 file."""
        content = "Valid UTF-8 content with unicode: 🔐"
        test_file = Path(self.temp_dir) / "valid_utf8.txt"
        test_file.write_text(content, encoding="utf-8")

        is_valid, error_msg = validate_utf8_encoding(str(test_file))
        self.assertTrue(is_valid)
        self.assertIsNone(error_msg)

    def test_validate_invalid_utf8(self):
        """Test validation of invalid UTF-8 file."""
        test_file = Path(self.temp_dir) / "invalid_utf8.txt"
        with open(test_file, "wb") as f:
            f.write(b"\x80\x81\x82")  # Invalid UTF-8 sequence

        is_valid, error_msg = validate_utf8_encoding(str(test_file))
        self.assertFalse(is_valid)
        self.assertIn("Invalid UTF-8 encoding", error_msg)

    @patch("builtins.open", side_effect=Exception("Read error"))
    def test_validate_utf8_read_error(self, mock_file):
        """Test validation handles file read errors."""
        test_file = Path(self.temp_dir) / "test_error.txt"
        test_file.write_text("content", encoding="utf-8")

        is_valid, error_msg = validate_utf8_encoding(str(test_file))
        self.assertFalse(is_valid)
        self.assertIn("Error reading file", error_msg)


class TestFilePermissions(unittest.TestCase):
    """Test file permission checking functionality."""

    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up test fixtures."""
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_check_valid_file_permissions(self):
        """Test checking permissions for readable file."""
        content = "Test content"
        test_file = Path(self.temp_dir) / "readable.txt"
        test_file.write_text(content, encoding="utf-8")

        has_perms, error_msg = check_file_permissions(str(test_file))
        self.assertTrue(has_perms)
        self.assertIsNone(error_msg)

    def test_check_nonexistent_file_permissions(self):
        """Test checking permissions for non-existent file."""
        has_perms, error_msg = check_file_permissions("/path/that/does/not/exist.txt")
        self.assertFalse(has_perms)
        self.assertIn("File does not exist", error_msg)

    def test_check_directory_permissions(self):
        """Test checking permissions when path is directory."""
        has_perms, error_msg = check_file_permissions(self.temp_dir)
        self.assertFalse(has_perms)
        self.assertIn("Path is not a file", error_msg)

    @patch("builtins.open", side_effect=PermissionError("Permission denied"))
    def test_check_permission_denied(self, mock_file):
        """Test checking permissions when permission denied."""
        test_file = Path(self.temp_dir) / "test_perms.txt"
        test_file.write_text("content", encoding="utf-8")

        has_perms, error_msg = check_file_permissions(str(test_file))
        self.assertFalse(has_perms)
        self.assertIn("Permission denied reading file", error_msg)

    @patch("builtins.open", side_effect=Exception("Other error"))
    def test_check_permissions_other_error(self, mock_file):
        """Test checking permissions with other errors."""
        test_file = Path(self.temp_dir) / "test_error.txt"
        test_file.write_text("content", encoding="utf-8")

        has_perms, error_msg = check_file_permissions(str(test_file))
        self.assertFalse(has_perms)
        self.assertIn("Error checking file permissions", error_msg)


if __name__ == "__main__":
    unittest.main()
